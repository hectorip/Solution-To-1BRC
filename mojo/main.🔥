
from csv import CsvTable
from mojo_hash.hashmap import HashMapDict
from mojo_hash.fnv1a import fnv1a64
from collections.dict import Dict, KeyElement

@value
struct StringKey(KeyElement):
    var s: String

    fn __init__(inout self, owned s: String):
        self.s = s ^

    fn __init__(inout self, s: StringLiteral):
        self.s = String(s)

    fn __hash__(self) -> Int:
        return hash(self.s)

    fn __eq__(self, other: Self) -> Bool:
        return self.s == other.s

@value
struct Measurement(CollectionElement):
    var count: Int
    var sum: Float64
    var max: Float64
    var min: Float64


fn parseFloat(s: String) -> Float64:
    let f: Float64

    try:
      let parts = s.split('.')
      let whole = atol(parts[0])
      let frac = atol(parts[1])
      f = whole + frac / 10
    except:
      f = 0.0
    return f

fn main() raises:
    var map = Dict[StringKey, Measurement]()
    with open('../../measurements.txt', 'r') as f:
      let csv = CsvTable(f.read(), True)
      # print(csv.row_count())
      var i = 0
      var name = csv.get(i, 0)
      while name != "":
        let m = parseFloat(csv.get(i, 1))
        var cm = map.find(name).or_else(Measurement(0, 0, 0, 0)).value()
        cm.count += 1
        cm.sum += m
        cm.max = m if m > cm.max else cm.max
        cm.min = m if m < cm.min else cm.min
        map[name] = cm
        i += 1
        name = csv.get(i, 0)
        # print(i, name)
    # print(map)
